---
slug: longest-subarray-1438
title: 力扣1438-绝对差不超过限制的最长连续子数组[滑动窗口+单调队列]
authors: yana
tags: [algorithm, leetcode, longestSubarray]
---

## 原题

```text

给你一个整数数组 nums ，和一个表示限制的整数 limit，请你返回最长连续子数组的长度，该子数组中的任意两个元素之间的绝对差必须小于或者等于 limit 。

如果不存在满足条件的子数组，则返回 0 。



示例 1：

输入：nums = [8,2,4,7], limit = 4
输出：2
解释：所有子数组如下：
[8] 最大绝对差 |8-8| = 0 <= 4.
[8,2] 最大绝对差 |8-2| = 6 > 4.
[8,2,4] 最大绝对差 |8-2| = 6 > 4.
[8,2,4,7] 最大绝对差 |8-2| = 6 > 4.
[2] 最大绝对差 |2-2| = 0 <= 4.
[2,4] 最大绝对差 |2-4| = 2 <= 4.
[2,4,7] 最大绝对差 |2-7| = 5 > 4.
[4] 最大绝对差 |4-4| = 0 <= 4.
[4,7] 最大绝对差 |4-7| = 3 <= 4.
[7] 最大绝对差 |7-7| = 0 <= 4.
因此，满足题意的最长子数组的长度为 2 。
示例 2：

输入：nums = [10,1,2,4,7,2], limit = 5
输出：4
解释：满足题意的最长子数组是 [2,4,7,2]，其最大绝对差 |2-7| = 5 <= 5 。
示例 3：

输入：nums = [4,2,2,2,4,4,2,2], limit = 0
输出：3


提示：

1 <= nums.length <= 10^5
1 <= nums[i] <= 10^9
0 <= limit <= 10^9
```

## 分析

1. 求连续子数组，考虑滑动窗口
2. 求差值考虑连续区间内的最大、最小值[每次更新极值会把不符合的数据都清除出去]
3. 窗口不符合时,检查极端值是否包含区间值，如果是，移除这个极端值队头

## 解题思路

1. 创建左右指针 l、r
2. 遍历 nums 数组
   - 固定 r 右侧指针，当 `差值 > limit ~ （max([l,r]) - min([l,r]) > limit）` 内部循环被打破的时候，收缩左侧指针
   - 创建最大值队列 queMax（单调减队列），循环内部将 nums[r] 与队尾元素比较，如果 nums[r] 大于队尾，将队尾元素推出队伍
     【while】
   - 创建最小值队列 queMin（单调增队列），循环内部将 nums[r] 与队尾元素比较，如果 nums[r] 小于队尾，将队尾元素推出队伍
     【while】
   - 一定会将 nums[r] 推入到两个队列
   - 一旦符合收缩左区间条件 `queMax.length && queMin.length && queMax - queMin > limit`，收缩左区间 `l++`,在此之前同时判
     断 l 所在元素是否为两个队列的头部，如果是移除头部元素 queMax.shift() / queMin.shift()
   - 在每个循环内部去更新最终输出的子数组的长度

## 伪代码

```js
nums = [8, 2, 4, 7]
limit = 4
```

| right | nums\[right] | maxDeque | minDeque          | max-min | left | res | 当前窗口 |
| ----- | ------------ | -------- | ----------------- | ------- | ---- | --- | -------- |
| 0     | 8            | \[8]     | \[8]              | 0       | 0    | 1   | \[8]     |
| 1     | 2            | \[8,2]   | \[2]              | 6       | 1    | 1   | \[2]     |
| 2     | 4            | \[4]     | \[2,4]            | 2       | 1    | 2   | \[2,4]   |
| 3     | 7            | \[7]     | \[2,4,7] → \[2,4] | 5       | 2    | 2   | \[4,7]   |

## 代码

```js
/**
 * @param {number[]} nums
 * @param {number} limit
 * @return {number}
 */
function longestSubarray(nums, limit) {
  let l = 0
  let r = 0

  let queMax = [] // ∞...0
  let queMin = [] // 0...∞

  let ans = 0 // 记录子数组长度

  while (r < nums.length) {
    while (queMax.length && nums[r] > queMax[queMax.length - 1]) {
      // nums[r] 比单调递减队列还大，把尾部小于 nums[r] 的数据清除出队列
      queMax.pop()
    }
    queMax.push(nums[r]) // 将新的值压入到单调递减队列(这也是后续检查端口值的原因)
    while (queMin.length && nums[r] < queMin[queMin.length - 1]) {
      // nums[r] 比单调递增队列还小，把尾部大于 nums[r] 的数据清除出队列
      queMin.pop()
    }
    queMin.push(nums[r]) // 将新的值压入到单调递减队列(这也是后续检查端口值的原因)

    // 如果差值超出限制值 limit，收缩左区间，移除和左区间值相等的最大最小值（在队列中不需要管，后续更新队列最大最小值的话会被直接清理出去）
    while (queMax.length && queMin.length && Math.abs(queMax[0] - queMin[0]) > limit) {
      if (queMax[0] === nums[l]) {
        // 注意：易错点
        queMax.shift()
      }
      if (queMin[0] === nums[l]) {
        // 注意：易错点
        queMin.shift()
      }
      l++
    }

    // 更新子数组长度到 ans
    ans = Math.max(ans, r - l + 1)

    r++ // 确保 r 增加
  }
  return ans
}
```

## 推荐关联（easy -> hard）

- 1004 基础滑动窗口
- 239 单调队列
- 1438 滑动窗口 + 单调队列
- 1696/862 单调队列优化 DP
- 480 中位数窗口复杂的数据结构维护
